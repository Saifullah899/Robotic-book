"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[907],{7639:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"chapter-4-motion/chapter","title":"Chapter 4 - Motion Planning and Control","description":"Motion planning algorithms, trajectory generation, control theory, and locomotion methods for navigating and moving in physical environments","source":"@site/docs/chapter-4-motion/chapter.md","sourceDirName":"chapter-4-motion","slug":"/chapter-4-motion/chapter","permalink":"/Robotic-book/docs/chapter-4-motion/chapter","draft":false,"unlisted":false,"editUrl":"https://github.com/Saifullah899/Robotic-book/tree/main/website/docs/chapter-4-motion/chapter.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Chapter 4 - Motion Planning and Control","sidebar_position":4,"description":"Motion planning algorithms, trajectory generation, control theory, and locomotion methods for navigating and moving in physical environments"},"sidebar":"textbookSidebar","previous":{"title":"Chapter 3 - Perception and Sensing","permalink":"/Robotic-book/docs/chapter-3-perception/chapter"},"next":{"title":"Chapter 5 - Manipulation and Interaction","permalink":"/Robotic-book/docs/chapter-5-manipulation/chapter"}}');var l=e(4848),t=e(8453);const r={title:"Chapter 4 - Motion Planning and Control",sidebar_position:4,description:"Motion planning algorithms, trajectory generation, control theory, and locomotion methods for navigating and moving in physical environments"},s="Chapter 4: Motion Planning and Control",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"4.1 Motion Planning Fundamentals",id:"41-motion-planning-fundamentals",level:2},{value:"4.1.1 Configuration Space and State Space",id:"411-configuration-space-and-state-space",level:3},{value:"4.1.2 Planning Paradigms",id:"412-planning-paradigms",level:3},{value:"4.1.3 Complete vs. Probabilistic Completeness",id:"413-complete-vs-probabilistic-completeness",level:3},{value:"4.2 Sampling-Based Motion Planning",id:"42-sampling-based-motion-planning",level:2},{value:"4.2.1 Probabilistic Roadmap (PRM)",id:"421-probabilistic-roadmap-prm",level:3},{value:"4.2.2 Rapidly-exploring Random Trees (RRT)",id:"422-rapidly-exploring-random-trees-rrt",level:3},{value:"4.2.3 Optimization-Based Planning",id:"423-optimization-based-planning",level:3},{value:"4.3 Trajectory Generation and Smoothing",id:"43-trajectory-generation-and-smoothing",level:2},{value:"4.3.1 Path to Trajectory Conversion",id:"431-path-to-trajectory-conversion",level:3},{value:"4.3.2 Trajectory Smoothing",id:"432-trajectory-smoothing",level:3},{value:"4.3.3 Dynamic Feasibility",id:"433-dynamic-feasibility",level:3},{value:"4.4 Control Theory for Motion",id:"44-control-theory-for-motion",level:2},{value:"4.4.1 Feedback Control Fundamentals",id:"441-feedback-control-fundamentals",level:3},{value:"4.4.2 Advanced Control Techniques",id:"442-advanced-control-techniques",level:3},{value:"4.4.3 Nonlinear Control",id:"443-nonlinear-control",level:3},{value:"4.5 Locomotion Methods",id:"45-locomotion-methods",level:2},{value:"4.5.1 Wheeled Locomotion",id:"451-wheeled-locomotion",level:3},{value:"4.5.2 Legged Locomotion",id:"452-legged-locomotion",level:3},{value:"4.5.3 Specialized Locomotion",id:"453-specialized-locomotion",level:3},{value:"4.6 Real-time Motion Control",id:"46-real-time-motion-control",level:2},{value:"4.6.1 Real-time Constraints",id:"461-real-time-constraints",level:3},{value:"4.6.2 Adaptive Motion Planning",id:"462-adaptive-motion-planning",level:3},{value:"4.6.3 Safety and Collision Avoidance",id:"463-safety-and-collision-avoidance",level:3},{value:"4.7 Performance Evaluation and Metrics",id:"47-performance-evaluation-and-metrics",level:2},{value:"4.7.1 Planning Performance Metrics",id:"471-planning-performance-metrics",level:3},{value:"4.7.2 Control Performance Metrics",id:"472-control-performance-metrics",level:3},{value:"4.8 Integration Challenges",id:"48-integration-challenges",level:2},{value:"4.8.1 Perception-Action Coupling",id:"481-perception-action-coupling",level:3},{value:"4.8.2 Multi-Robot Coordination",id:"482-multi-robot-coordination",level:3},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2},{value:"Exercises",id:"exercises",level:2}];function d(n){const i={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.header,{children:(0,l.jsx)(i.h1,{id:"chapter-4-motion-planning-and-control",children:"Chapter 4: Motion Planning and Control"})}),"\n",(0,l.jsx)(i.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,l.jsx)(i.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Understand fundamental motion planning algorithms and their applications"}),"\n",(0,l.jsx)(i.li,{children:"Analyze different trajectory generation techniques for smooth robot motion"}),"\n",(0,l.jsx)(i.li,{children:"Apply control theory principles to robot motion and stabilization"}),"\n",(0,l.jsx)(i.li,{children:"Compare various locomotion methods for different robot types"}),"\n",(0,l.jsx)(i.li,{children:"Evaluate motion planning and control performance in real-world scenarios"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,l.jsx)(i.p,{children:"Motion planning and control form the core of Physical AI's ability to navigate and interact with the physical world. Unlike virtual AI that operates on abstract data, Physical AI must generate precise, safe, and efficient movements that account for the constraints and dynamics of the physical environment. This chapter explores the algorithms, techniques, and control strategies that enable robots to move purposefully and safely through complex physical spaces."}),"\n",(0,l.jsx)(i.h2,{id:"41-motion-planning-fundamentals",children:"4.1 Motion Planning Fundamentals"}),"\n",(0,l.jsx)(i.p,{children:"Motion planning is the process of determining a sequence of valid configurations that moves a robot from an initial state to a goal state while avoiding obstacles and satisfying various constraints."}),"\n",(0,l.jsx)(i.h3,{id:"411-configuration-space-and-state-space",children:"4.1.1 Configuration Space and State Space"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Configuration Space (C-space)"}),": The space of all possible configurations of a robot:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Each point in C-space represents a complete configuration of the robot"}),"\n",(0,l.jsx)(i.li,{children:"For a robot with n degrees of freedom, C-space is n-dimensional"}),"\n",(0,l.jsx)(i.li,{children:"Obstacles in the physical world map to C-space obstacles (C-obstacles)"}),"\n",(0,l.jsx)(i.li,{children:"Valid configurations form the free space (C-free)"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"State Space"}),": Includes both position and velocity information:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Configuration space with velocity dimensions"}),"\n",(0,l.jsx)(i.li,{children:"Essential for dynamic motion planning"}),"\n",(0,l.jsx)(i.li,{children:"Accounts for robot dynamics and constraints"}),"\n",(0,l.jsx)(i.li,{children:"Higher dimensional than configuration space alone"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"412-planning-paradigms",children:"4.1.2 Planning Paradigms"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Discrete Planning"}),": Planning in a discretized representation:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Grid-based approaches: Divide space into discrete cells"}),"\n",(0,l.jsx)(i.li,{children:"Graph-based methods: Represent space as a network of connected nodes"}),"\n",(0,l.jsx)(i.li,{children:"Search algorithms: A*, Dijkstra's algorithm, D* for pathfinding"}),"\n",(0,l.jsx)(i.li,{children:"Advantages: Guaranteed completeness, simple implementation"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Continuous Planning"}),": Planning in the full continuous space:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Sampling-based methods: Probabilistic Roadmaps (PRM), Rapidly-exploring Random Trees (RRT)"}),"\n",(0,l.jsx)(i.li,{children:"Optimization-based methods: Trajectory optimization, direct collocation"}),"\n",(0,l.jsx)(i.li,{children:"Advantages: Handle high-dimensional spaces, natural representation"}),"\n",(0,l.jsx)(i.li,{children:"Disadvantages: Probabilistic completeness, complex implementation"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"413-complete-vs-probabilistic-completeness",children:"4.1.3 Complete vs. Probabilistic Completeness"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Complete Algorithms"}),": Guaranteed to find a solution if one exists:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Grid-based search in bounded spaces"}),"\n",(0,l.jsx)(i.li,{children:"Visibility graph methods"}),"\n",(0,l.jsx)(i.li,{children:"Cell decomposition approaches"}),"\n",(0,l.jsx)(i.li,{children:"Computational complexity grows exponentially with dimension"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Probabilistically Complete"}),": Find a solution if one exists given sufficient time:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"RRT, PRM, and their variants"}),"\n",(0,l.jsx)(i.li,{children:"Sampling-based approaches"}),"\n",(0,l.jsx)(i.li,{children:"More scalable to high-dimensional spaces"}),"\n",(0,l.jsx)(i.li,{children:"No guarantee of finding solution in finite time"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"42-sampling-based-motion-planning",children:"4.2 Sampling-Based Motion Planning"}),"\n",(0,l.jsx)(i.p,{children:"Sampling-based methods are particularly effective for high-dimensional motion planning problems common in Physical AI systems."}),"\n",(0,l.jsx)(i.h3,{id:"421-probabilistic-roadmap-prm",children:"4.2.1 Probabilistic Roadmap (PRM)"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Construction Phase"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Sample random configurations in free space"}),"\n",(0,l.jsx)(i.li,{children:"Connect nearby configurations if collision-free path exists"}),"\n",(0,l.jsx)(i.li,{children:"Build roadmap of possible paths"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Query Phase"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Connect start and goal configurations to roadmap"}),"\n",(0,l.jsx)(i.li,{children:"Use graph search to find path through roadmap"}),"\n",(0,l.jsx)(i.li,{children:"Extract and smooth the resulting path"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Advantages"}),": Good for multiple queries, reusable roadmap\r\n",(0,l.jsx)(i.strong,{children:"Disadvantages"}),": Poor for narrow passages, preprocessing overhead"]}),"\n",(0,l.jsx)(i.h3,{id:"422-rapidly-exploring-random-trees-rrt",children:"4.2.2 Rapidly-exploring Random Trees (RRT)"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Basic RRT Algorithm"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Start with single node at initial configuration"}),"\n",(0,l.jsx)(i.li,{children:"Randomly sample configuration space"}),"\n",(0,l.jsx)(i.li,{children:"Extend tree toward samples in collision-free manner"}),"\n",(0,l.jsx)(i.li,{children:"Continue until goal region reached or time limit"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"RRT Variants"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"RRT*: Asymptotically optimal, finds near-optimal solutions"}),"\n",(0,l.jsx)(i.li,{children:"RRT-Connect: Bidirectional search for faster convergence"}),"\n",(0,l.jsx)(i.li,{children:"Anytime RRT: Balances exploration and optimization over time"}),"\n",(0,l.jsx)(i.li,{children:"Task Space RRT: Plan directly in task-relevant coordinates"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"423-optimization-based-planning",children:"4.2.3 Optimization-Based Planning"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Trajectory Optimization"}),": Formulate planning as optimization problem:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Define cost function (path length, smoothness, energy)"}),"\n",(0,l.jsx)(i.li,{children:"Define constraints (dynamics, obstacles, actuator limits)"}),"\n",(0,l.jsx)(i.li,{children:"Use numerical optimization to find optimal trajectory"}),"\n",(0,l.jsx)(i.li,{children:"Direct collocation, shooting methods, pseudospectral methods"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Model Predictive Control (MPC)"}),": Receding horizon optimization:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Plan over finite horizon using model"}),"\n",(0,l.jsx)(i.li,{children:"Execute first portion of plan"}),"\n",(0,l.jsx)(i.li,{children:"Re-plan at each time step with updated information"}),"\n",(0,l.jsx)(i.li,{children:"Handles constraints and disturbances well"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"43-trajectory-generation-and-smoothing",children:"4.3 Trajectory Generation and Smoothing"}),"\n",(0,l.jsx)(i.p,{children:"Once a path is planned, it must be converted to a time-parameterized trajectory that respects robot dynamics and constraints."}),"\n",(0,l.jsx)(i.h3,{id:"431-path-to-trajectory-conversion",children:"4.3.1 Path to Trajectory Conversion"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Velocity Profiles"}),": Assign velocities along geometric path:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Trapezoidal velocity profiles: Acceleration, constant velocity, deceleration"}),"\n",(0,l.jsx)(i.li,{children:"S-curve profiles: Smooth acceleration changes for reduced jerk"}),"\n",(0,l.jsx)(i.li,{children:"Time-optimal parameterization: Minimize execution time"}),"\n",(0,l.jsx)(i.li,{children:"Velocity- and acceleration-bounded profiles"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Time Parameterization"}),": Assign timing information to path:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Kinodynamic planning: Consider both kinematic and dynamic constraints"}),"\n",(0,l.jsx)(i.li,{children:"Time-optimal path following: Minimize execution time"}),"\n",(0,l.jsx)(i.li,{children:"Dynamic window approach: Consider robot dynamics in real-time"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"432-trajectory-smoothing",children:"4.3.2 Trajectory Smoothing"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Polynomial Interpolation"}),": Use polynomials for smooth transitions:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Cubic splines: C\xb2 continuous, smooth curvature"}),"\n",(0,l.jsx)(i.li,{children:"Quintic polynomials: C\xb3 continuous, smooth jerk"}),"\n",(0,l.jsx)(i.li,{children:"B\xe9zier curves: Parametric curves with control points"}),"\n",(0,l.jsx)(i.li,{children:"B-splines: Piecewise polynomial curves with local control"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Optimization-based Smoothing"}),": Minimize specific criteria:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Minimize path length while maintaining feasibility"}),"\n",(0,l.jsx)(i.li,{children:"Minimize curvature for smooth motion"}),"\n",(0,l.jsx)(i.li,{children:"Minimize jerk for comfortable motion"}),"\n",(0,l.jsx)(i.li,{children:"Balance multiple objectives with weighted costs"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"433-dynamic-feasibility",children:"4.3.3 Dynamic Feasibility"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Differential Constraints"}),": Account for robot dynamics:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Holonomic constraints: Position-only constraints"}),"\n",(0,l.jsx)(i.li,{children:"Nonholonomic constraints: Velocity or higher-order constraints"}),"\n",(0,l.jsx)(i.li,{children:"Pfaffian constraints: Linear velocity constraints"}),"\n",(0,l.jsx)(i.li,{children:"Examples: Car-like robots, rolling contacts"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Actuator Constraints"}),": Respect physical limitations:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Velocity limits: Maximum achievable velocities"}),"\n",(0,l.jsx)(i.li,{children:"Acceleration limits: Maximum achievable accelerations"}),"\n",(0,l.jsx)(i.li,{children:"Torque/force limits: Maximum actuator capabilities"}),"\n",(0,l.jsx)(i.li,{children:"Power constraints: Limited power availability"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"44-control-theory-for-motion",children:"4.4 Control Theory for Motion"}),"\n",(0,l.jsx)(i.p,{children:"Control theory provides the mathematical foundation for generating and executing robot motions."}),"\n",(0,l.jsx)(i.h3,{id:"441-feedback-control-fundamentals",children:"4.4.1 Feedback Control Fundamentals"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Proportional-Integral-Derivative (PID) Control"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Proportional term: Corrects based on current error"}),"\n",(0,l.jsx)(i.li,{children:"Integral term: Eliminates steady-state error"}),"\n",(0,l.jsx)(i.li,{children:"Derivative term: Dampens oscillations"}),"\n",(0,l.jsx)(i.li,{children:"Tuning: Balance stability, response speed, and overshoot"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"State Feedback Control"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Linear Quadratic Regulator (LQR): Optimal control for linear systems"}),"\n",(0,l.jsx)(i.li,{children:"Pole placement: Design controller by placing closed-loop poles"}),"\n",(0,l.jsx)(i.li,{children:"Observer design: Estimate unmeasurable states"}),"\n",(0,l.jsx)(i.li,{children:"Linear Quadratic Gaussian (LQG): Handle noisy measurements"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"442-advanced-control-techniques",children:"4.4.2 Advanced Control Techniques"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Adaptive Control"}),": Adjust parameters based on changing conditions:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Model Reference Adaptive Control (MRAC): Follow reference model"}),"\n",(0,l.jsx)(i.li,{children:"Self-Tuning Regulators (STR): Online parameter estimation"}),"\n",(0,l.jsx)(i.li,{children:"Gain scheduling: Adjust gains based on operating conditions"}),"\n",(0,l.jsx)(i.li,{children:"Applications: Changing payloads, varying friction"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Robust Control"}),": Handle model uncertainty and disturbances:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"H\u221e control: Minimize worst-case performance"}),"\n",(0,l.jsx)(i.li,{children:"\u03bc-synthesis: Handle structured uncertainty"}),"\n",(0,l.jsx)(i.li,{children:"Sliding mode control: Robust to matched disturbances"}),"\n",(0,l.jsx)(i.li,{children:"Applications: Model inaccuracies, external disturbances"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"443-nonlinear-control",children:"4.4.3 Nonlinear Control"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Feedback Linearization"}),": Transform nonlinear system to linear:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Exact linearization: Perfect transformation when possible"}),"\n",(0,l.jsx)(i.li,{children:"Approximate linearization: Linearize around operating point"}),"\n",(0,l.jsx)(i.li,{children:"Input-output linearization: Linearize input-output behavior"}),"\n",(0,l.jsx)(i.li,{children:"Applications: Manipulator control, vehicle control"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Lyapunov-based Control"}),": Use energy-like functions:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Direct method: Analyze stability using Lyapunov functions"}),"\n",(0,l.jsx)(i.li,{children:"Indirect method: Linearize and analyze"}),"\n",(0,l.jsx)(i.li,{children:"Control Lyapunov functions: Design stabilizing controllers"}),"\n",(0,l.jsx)(i.li,{children:"Applications: Stabilization, tracking control"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"45-locomotion-methods",children:"4.5 Locomotion Methods"}),"\n",(0,l.jsx)(i.p,{children:"Different types of robots use various locomotion methods to move through their environment."}),"\n",(0,l.jsx)(i.h3,{id:"451-wheeled-locomotion",children:"4.5.1 Wheeled Locomotion"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Types of Wheels"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Standard wheels: Fixed orientation, constrained motion"}),"\n",(0,l.jsx)(i.li,{children:"Castor wheels: Free-rotating, omnidirectional capability"}),"\n",(0,l.jsx)(i.li,{children:"Swedish wheels: Rollers for lateral motion"}),"\n",(0,l.jsx)(i.li,{children:"Spherical wheels: Full omnidirectional motion"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Vehicle Configurations"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Differential drive: Two independently controlled wheels"}),"\n",(0,l.jsx)(i.li,{children:"Ackermann steering: Car-like steering mechanism"}),"\n",(0,l.jsx)(i.li,{children:"Mecanum wheels: Full omnidirectionality"}),"\n",(0,l.jsx)(i.li,{children:"Omnidirectional platforms: Move in any direction"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Advantages"}),": Energy efficient, precise positioning, well-understood\r\n",(0,l.jsx)(i.strong,{children:"Disadvantages"}),": Limited terrain capability, nonholonomic constraints"]}),"\n",(0,l.jsx)(i.h3,{id:"452-legged-locomotion",children:"4.5.2 Legged Locomotion"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Bipedal Locomotion"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Static stability: Center of mass within support polygon"}),"\n",(0,l.jsx)(i.li,{children:"Dynamic stability: Controlled falling during gait"}),"\n",(0,l.jsx)(i.li,{children:"Zero Moment Point (ZMP): Balance criterion for walking"}),"\n",(0,l.jsx)(i.li,{children:"Linear Inverted Pendulum Model (LIPM): Simplified walking model"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Quadrupedal Locomotion"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Gaits: Walk, trot, pace, bound, gallop"}),"\n",(0,l.jsx)(i.li,{children:"Static vs. dynamic gaits: Stability considerations"}),"\n",(0,l.jsx)(i.li,{children:"Ground reaction forces: Force distribution during locomotion"}),"\n",(0,l.jsx)(i.li,{children:"Applications: Rough terrain navigation, climbing"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Multi-legged Systems"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Hexapod locomotion: Insect-like walking"}),"\n",(0,l.jsx)(i.li,{children:"Stability: Always maintain tripod of support"}),"\n",(0,l.jsx)(i.li,{children:"Gait patterns: Tripod, wave, ripple gaits"}),"\n",(0,l.jsx)(i.li,{children:"Fault tolerance: Continue operation with leg failure"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"453-specialized-locomotion",children:"4.5.3 Specialized Locomotion"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Aerial Locomotion"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Fixed-wing: Efficient long-distance flight"}),"\n",(0,l.jsx)(i.li,{children:"Rotary-wing: VTOL capability, hovering"}),"\n",(0,l.jsx)(i.li,{children:"Flapping-wing: Biomimetic flight"}),"\n",(0,l.jsx)(i.li,{children:"Control challenges: Underactuated, unstable"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Aquatic Locomotion"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Propeller-based: Thrust generation with propellers"}),"\n",(0,l.jsx)(i.li,{children:"Paddle-based: Biomimetic swimming"}),"\n",(0,l.jsx)(i.li,{children:"Undulatory: Wave-like body motion"}),"\n",(0,l.jsx)(i.li,{children:"Buoyancy control: Depth regulation"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"46-real-time-motion-control",children:"4.6 Real-time Motion Control"}),"\n",(0,l.jsx)(i.p,{children:"Physical AI systems must execute motion plans in real-time while adapting to environmental changes."}),"\n",(0,l.jsx)(i.h3,{id:"461-real-time-constraints",children:"4.6.1 Real-time Constraints"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Timing Requirements"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Control loop frequencies: 100Hz to 1kHz for different applications"}),"\n",(0,l.jsx)(i.li,{children:"Sensor fusion rates: Synchronize with sensor capabilities"}),"\n",(0,l.jsx)(i.li,{children:"Trajectory updates: Adapt to changing conditions"}),"\n",(0,l.jsx)(i.li,{children:"Communication delays: Account for network latencies"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Computational Efficiency"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Algorithm complexity: O(n) vs O(n\xb2) vs O(n\xb3) considerations"}),"\n",(0,l.jsx)(i.li,{children:"Memory usage: Limited memory in embedded systems"}),"\n",(0,l.jsx)(i.li,{children:"Numerical precision: Balance accuracy and speed"}),"\n",(0,l.jsx)(i.li,{children:"Parallel processing: Utilize multi-core architectures"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"462-adaptive-motion-planning",children:"4.6.2 Adaptive Motion Planning"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Reactive Planning"}),": Adjust to immediate environmental changes:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Obstacle avoidance: Detect and avoid unexpected obstacles"}),"\n",(0,l.jsx)(i.li,{children:"Dynamic replanning: Update plans as environment changes"}),"\n",(0,l.jsx)(i.li,{children:"Emergency stops: Safe stopping procedures"}),"\n",(0,l.jsx)(i.li,{children:"Local path adjustment: Small modifications to global plan"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Predictive Planning"}),": Anticipate future changes:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Moving obstacles: Predict and avoid dynamic obstacles"}),"\n",(0,l.jsx)(i.li,{children:"Uncertain environments: Plan for multiple possible scenarios"}),"\n",(0,l.jsx)(i.li,{children:"Human-robot interaction: Anticipate human behavior"}),"\n",(0,l.jsx)(i.li,{children:"Multi-robot coordination: Plan considering other robots"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"463-safety-and-collision-avoidance",children:"4.6.3 Safety and Collision Avoidance"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Safety-Critical Systems"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Fail-safe mechanisms: Safe state in case of failure"}),"\n",(0,l.jsx)(i.li,{children:"Collision detection: Real-time collision checking"}),"\n",(0,l.jsx)(i.li,{children:"Emergency protocols: Immediate response procedures"}),"\n",(0,l.jsx)(i.li,{children:"Risk assessment: Evaluate and mitigate risks"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Proactive Safety"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Predictive safety: Anticipate potential hazards"}),"\n",(0,l.jsx)(i.li,{children:"Safe corridors: Maintain safe regions around robot"}),"\n",(0,l.jsx)(i.li,{children:"Velocity scaling: Reduce speed in risky situations"}),"\n",(0,l.jsx)(i.li,{children:"Human-aware planning: Consider human safety"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"47-performance-evaluation-and-metrics",children:"4.7 Performance Evaluation and Metrics"}),"\n",(0,l.jsx)(i.p,{children:"Evaluating motion planning and control systems is crucial for Physical AI applications."}),"\n",(0,l.jsx)(i.h3,{id:"471-planning-performance-metrics",children:"4.7.1 Planning Performance Metrics"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Completeness and Optimality"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Success rate: Percentage of successful planning attempts"}),"\n",(0,l.jsx)(i.li,{children:"Solution quality: Deviation from optimal solution"}),"\n",(0,l.jsx)(i.li,{children:"Computation time: Time to generate plan"}),"\n",(0,l.jsx)(i.li,{children:"Memory usage: Storage requirements for planning"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Robustness Metrics"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Failure rate: Frequency of planning failures"}),"\n",(0,l.jsx)(i.li,{children:"Replanning frequency: How often plan needs updating"}),"\n",(0,l.jsx)(i.li,{children:"Solution stability: Consistency across similar problems"}),"\n",(0,l.jsx)(i.li,{children:"Scalability: Performance as problem complexity increases"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"472-control-performance-metrics",children:"4.7.2 Control Performance Metrics"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Tracking Performance"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Position error: Deviation from desired trajectory"}),"\n",(0,l.jsx)(i.li,{children:"Velocity error: Deviation in velocity profile"}),"\n",(0,l.jsx)(i.li,{children:"Tracking accuracy: Overall trajectory following"}),"\n",(0,l.jsx)(i.li,{children:"Settling time: Time to reach steady state"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Stability and Smoothness"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Oscillation: Stability of control response"}),"\n",(0,l.jsx)(i.li,{children:"Jerk: Rate of change of acceleration"}),"\n",(0,l.jsx)(i.li,{children:"Energy efficiency: Power consumption during motion"}),"\n",(0,l.jsx)(i.li,{children:"Smoothness: Continuity of motion profiles"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"48-integration-challenges",children:"4.8 Integration Challenges"}),"\n",(0,l.jsx)(i.p,{children:"Motion planning and control must be integrated with other robot systems for effective Physical AI."}),"\n",(0,l.jsx)(i.h3,{id:"481-perception-action-coupling",children:"4.8.1 Perception-Action Coupling"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Closed-loop Integration"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Sensor feedback: Use perception to correct motion"}),"\n",(0,l.jsx)(i.li,{children:"Uncertainty handling: Account for perception uncertainty"}),"\n",(0,l.jsx)(i.li,{children:"Multi-sensor fusion: Combine different sensor modalities"}),"\n",(0,l.jsx)(i.li,{children:"Real-time adaptation: Update plans based on new information"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Uncertainty Management"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"State estimation: Combine motion and perception"}),"\n",(0,l.jsx)(i.li,{children:"Probabilistic planning: Account for uncertainty in planning"}),"\n",(0,l.jsx)(i.li,{children:"Robust control: Handle uncertain environments"}),"\n",(0,l.jsx)(i.li,{children:"Risk-aware planning: Consider probability of success"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"482-multi-robot-coordination",children:"4.8.2 Multi-Robot Coordination"}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Distributed Motion Planning"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Communication protocols: Share planning information"}),"\n",(0,l.jsx)(i.li,{children:"Conflict resolution: Avoid collisions between robots"}),"\n",(0,l.jsx)(i.li,{children:"Task allocation: Assign motion tasks to robots"}),"\n",(0,l.jsx)(i.li,{children:"Consensus algorithms: Reach agreement on plans"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Formation Control"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Leader-follower: One robot leads others follow"}),"\n",(0,l.jsx)(i.li,{children:"Virtual structure: Maintain geometric formation"}),"\n",(0,l.jsx)(i.li,{children:"Behavior-based: Local rules for global behavior"}),"\n",(0,l.jsx)(i.li,{children:"Applications: Search and rescue, exploration"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,l.jsx)(i.p,{children:"This chapter has explored the fundamental concepts of motion planning and control that enable Physical AI systems to navigate and move effectively in physical environments. From basic planning algorithms to advanced control techniques, these systems must account for the physical constraints and dynamics of both the robot and its environment. The integration of perception, planning, and control forms the backbone of effective Physical AI systems, enabling robots to move purposefully and safely through complex physical spaces."}),"\n",(0,l.jsx)(i.p,{children:"The next chapter will build on this foundation by examining manipulation and interaction techniques that allow robots to physically interact with objects and environments."}),"\n",(0,l.jsx)(i.h2,{id:"references",children:"References"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:"LaValle, S. M. (2006). Planning Algorithms. Cambridge University Press."}),"\n",(0,l.jsx)(i.li,{children:"Siciliano, B., & Khatib, O. (2016). Springer Handbook of Robotics. Springer."}),"\n",(0,l.jsx)(i.li,{children:"Spong, M. W., Hutchinson, S., & Vidyasagar, M. (2006). Robot Modeling and Control. Wiley."}),"\n",(0,l.jsx)(i.li,{children:"Kelly, A., & Nagaty, A. (2013). Path Planning for Mobile Robots. Springer."}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"exercises",children:"Exercises"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:"Implement a basic RRT algorithm for a 2D point robot navigating around obstacles."}),"\n",(0,l.jsx)(i.li,{children:"Design a trajectory generation system that creates smooth, dynamically feasible paths for a wheeled robot."}),"\n",(0,l.jsx)(i.li,{children:"Compare the performance of different path planning algorithms in various environments."}),"\n",(0,l.jsx)(i.li,{children:"Analyze the stability and tracking performance of a PID controller for robot motion."}),"\n"]})]})}function h(n={}){const{wrapper:i}={...(0,t.R)(),...n.components};return i?(0,l.jsx)(i,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}},8453:(n,i,e)=>{e.d(i,{R:()=>r,x:()=>s});var o=e(6540);const l={},t=o.createContext(l);function r(n){const i=o.useContext(t);return o.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function s(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:r(n.components),o.createElement(t.Provider,{value:i},n.children)}}}]);